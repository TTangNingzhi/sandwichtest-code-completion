{"repo":"MaterialsDiscovery\/PyChemia","revision":"dee8d4f6a9db07a52cc4a47e063ab28f5a9b9967","path":"pychemia\/code\/fireball\/fireball.py","modified":["pychemia\/code\/fireball\/fireball.py"],"prefix":"import os\nimport re\nimport subprocess\n\nimport numpy as np\n\nfrom pychemia import pcm_log, Structure\nfrom pychemia.utils.serializer import generic_serializer\nfrom pychemia.utils.periodic import atomic_number, atomic_symbol\nfrom ..codes import Codes\n\n\nclass FireBall(Codes):\n    def __init__(self, fdata_path=None):\n        self.workdir = None\n        # The five sections of Fireball\n        self.option = {}\n        self.tds = {}\n        self.quench = {}\n        self.tds = {}\n        self.mesh = {}\n        self.output = {}\n\n        self.fdata_path = os.path.abspath(fdata_path)\n        self.structure = None\n        self.binary = 'fireball.x'\n        self.runner = None\n        self.kpoints = None\n        Codes.__init__(self)\n\n    @property\n    def to_dict(self):\n        ret = {}\n        if self.option:\n            ret['option'] = self.option\n        if self.output:\n            ret['output'] = self.output\n        if self.quench:\n            ret['quench'] = self.quench\n        if self.mesh:\n            ret['mesh'] = self.mesh\n        if self.tds:\n            ret['tds'] = self.tds\n        return ret\n\n    @staticmethod\n    def from_dict(dictionary):\n        ret = FireBall()\n        if 'option' in dictionary:\n            ret.option = dictionary['option']\n        if 'output' in dictionary:\n            ret.option = dictionary['output']\n        if 'quench' in dictionary:\n            ret.option = dictionary['quench']\n        if 'mesh' in dictionary:\n            ret.option = dictionary['mesh']\n        if 'tds' in dictionary:\n            ret.option = dictionary['tds']\n        return ret\n\n    def initialize(self, structure, workdir=None, kpoints=None, binary='fireball.x'):\n        assert structure.is_perfect\n        self.structure = structure\n        if workdir is not None:\n            self.workdir = workdir\n        else:\n            self.workdir = '.'\n        if not os.path.lexists(self.workdir):\n            os.mkdir(self.workdir)\n        self.kpoints = kpoints\n        self.binary = binary\n\n    def set_inputs(self, rms=0.1):\n        self.write_input(filename=self.workdir + os.sep + 'fireball.in')\n        self.write_basis(filename=self.workdir + os.sep + 'input.bas')\n        if self.structure.is_periodic:\n            self.write_lattice(filename=self.workdir + os.sep + 'input.lvs')\n            self.write_kpoints(filename=self.workdir + os.sep + 'input.kpts')\n        self.link_fdata()\n        wf = open(self.workdir + os.sep + 'rms.input', 'w')\n        wf.write('%f\\n' % rms)\n        wf.close()\n\n    def get_outputs(self):\n        pass\n\n    def run(self, use_mpi=False, omp_max_threads=0, mpi_num_procs=1):\n        cwd = os.getcwd()\n        os.chdir(self.workdir)\n        stdout = open('fireball.log', 'w')\n        sp = subprocess.Popen(self.binary, stdout=stdout)\n        os.chdir(cwd)\n        self.runner = sp\n        return sp\n\n    def run_status(self):\n        if self.runner is None:\n            pcm_log.info('Fireball not finish')\n            filename = self.workdir + os.sep + 'fireball.log'\n            if os.path.exists(filename):\n                read_fireball_stdout(filename=filename)\n            return\n        if self.runner.poll() == 0:\n            pcm_log.info('Fireball complete normally')\n\n    def finalize(self):\n        pass\n\n    def write_input(self, filename='fireball.in'):\n\n        wf = open(filename, 'w')\n        wf.write(str(self))\n        wf.close()\n\n    def __str__(self):\n        ret = ''\n        if self.option:\n            ret += '&OPTION\\n'\n            for variable in sorted(self.option):\n                if isinstance(self.option[variable], str):\n                    ret += \"%s = '%s'\\n\" % (variable, str(self.option[variable]))\n                else:\n                    ret += '%s = %s\\n' % (variable, str(self.option[variable]))\n            ret += '&END\\n'\n\n        if self.output:\n            ret += '&OUTPUT\\n'\n            for variable in sorted(self.output):\n                ret += '%s = %s\\n' % (variable, str(self.output[variable]))\n            ret += '&END\\n'\n\n        if self.quench:\n            ret += '&QUENCH\\n'\n            for variable in sorted(self.quench):\n                ret += '%s = %s\\n' % (variable, str(self.quench[variable]))\n            ret += '&END\\n'\n\n        if self.mesh:\n            ret += '&MESH\\n'\n            for variable in sorted(self.mesh):\n                ret += '%s = %s\\n' % (variable, str(self.mesh[variable]))\n            ret += '&END\\n'\n\n        if self.tds:\n            ret += '&TDS\\n'\n            for variable in sorted(self.tds):\n                ret += '%s = %s\\n' % (variable, str(self.tds[variable]))\n            ret += '&END\\n'\n\n        return ret\n\n    def write_basis(self, filename='input.bas'):\n        write_geometry_bas(self.structure, filename)\n\n    def write_lattice(self, filename='input.lvs'):\n        wf = open(filename, 'w')\n        for i in range(3):\n            wf.write('%13.7f %13.7f %13.7f\\n' % (self.structure.cell[i, 0],\n                                                 self.structure.cell[i, 1],\n                                                 self.structure.cell[i, 2]))\n        wf.close()\n\n    def write_kpoints(self, filename):\n        pass\n\n    def link_fdata(self):\n        if self.fdata_path is not None:\n            linkpath = self.workdir + os.sep + 'Fdata'\n            if os.path.exists(linkpath):\n                os.remove(linkpath)\n            os.symlink(self.fdata_path, linkpath)\n\n    def cluster_relaxation(self):\n        self.option = {'basisfile': 'input.bas', 'nstepf': 5000, 'iquench': -3, 'icluster': 1, 'iqout': 3, 'dt': 0.25}\n        self.output = {'iwrtxyz': 1}\n\n\ndef read_fireball_stdout(filename):\n    rf = open(filename, 'r')\n    data = rf.read()\n\n    atom_data = re.findall(r'Atom Coordinates from Basis File:([\\d\\w\\s=\\-\\.#]+)===\\n', data)[0]\n\n    symbols = []\n    positions = []\n    for iline in atom_data.split('\\n'):\n        # print iline\n        tmp = iline.split()\n        if len(tmp) == 6 and tmp[0].isdigit():\n            symbols.append(tmp[1])\n            positions.append([float(x) for x in tmp[2:5]])\n\n    natom = len(symbols)\n    initial_positions = np.array(positions)\n    # print symbols\n    # print initial_positions\n\n    forces_data = re.findall(r'The grand total force \\(eV\/A\\):([\\w\\d\\s\\.\\-=\\+]*)Cartesian', data)\n    # print len(forces_data)\n\n    forces = np.zeros((len(forces_data), natom, 3))\n    # print forces.shape\n\n    iteration = 0\n    for idata in forces_data:\n        for iline in idata.split('\\n'):\n            if 'iatom' in iline:\n                fields = iline.split()\n                forces[iteration, int(fields[2]) - 1] = np.array(fields[-3:], dtype=float)\n        iteration += 1\n\n    ret = re.findall('Cartesian Forces:\\s*Max = ([=\\w\\s\\d.]*)RMS = ([\\s\\d.]*)\\n', data)\n    ret = [[float(x) for x in y] for y in ret]\n    max_force = [x[0] for x in ret]\n    rms = [x[1] for x in ret]\n\n    energy_data = re.findall(r'---------- T H E  T O T A L  E N E R G Y -----------([\\s\\w\\d\\.\\-=\/]+)--- \\n', data)\n\n    energy = []\n    for idata in energy_data:\n        for iline in idata.split('\\n'):\n            if 'Time step' in iline:\n                tmp = iline.split()\n                ienergy = {'Time_step': int(tmp[3]), 'SCF_step': int(tmp[7]), 'etot\/atom': float(tmp[10])}\n            elif len(iline.split('=')) == 2:\n                tmp = iline.split('=')\n                ienergy[tmp[0].strip()] = float(tmp[1])\n        energy.append(ienergy)\n\n    ret = {'symbols': symbols,\n           'initial_positions': initial_positions,\n           'forces': generic_serializer(forces),\n           'energetics': energy,\n           'max_force': max_force,\n           'rms_force': rms}\n    return ret\n\n\ndef read_geometry_bas(filename):\n    rf = open(filename, 'r')\n\n    natom = int(rf.readline())\n    symbols = []\n    positions = np.zeros((natom, 3))\n\n    for i in range(natom):\n        line = rf.readline().split()\n        symbols.append(atomic_symbol(int(line[0])))\n        positions[i] = np.array(line[1:])\n\n    return Structure(symbols=symbols, positions=positions, periodicity=False)\n\n\ndef write_geometry_bas(structure, filename):\n    wf = open(filename, 'w')\n    wf.write('%3d\\n' % structure.natom)\n    for i in range(structure.natom):\n        if structure.is_periodic:\n            x = structure.reduced[i, 0]\n            y = structure.reduced[i, 1]\n            z = structure.reduced[i, 2]\n        else:\n            x = structure.positions[i, 0]\n            y = structure.positions[i, 1]\n            z = structure.positions[i, 2]\n        wf.write('%3d %13.7f %13.7f %13.7f\\n' % (atomic_number(structure.symbols[i]), x, y, z))\n    wf.close()\n\n\ndef get_fdata_info(fdata_path='Fdata'):\n    rf = open(fdata_path + os.sep + 'info.dat')\n    data = rf.read()\n    ret = re.findall('([-. \\d\\w]*) \\- ([ \\d\\w;]*) \\n', data)\n    res = {}\n    for i in ret:\n        key = i[1]\n        value = i[0]\n        if key == 'Information for this species':\n            cur_atom = int(value)\n            res[cur_atom] = {}\n        elif key == 'Element':\n            res[cur_atom]['Element'] = value.strip()\n        elif key == 'Nuclear Z':\n            res[cur_atom]['Nuclear Z'] = int(value)\n        elif key == 'Atomic Mass':\n            res[cur_atom]['Atomic Mass'] = float(value)\n        elif key == 'Number of shells; L for each shell':\n            res[cur_atom]['Number of shells; L for each shell'] = int(value)\n        elif key == 'Radial cutoffs PP':\n            res[cur_atom]['Radial cutoffs PP'] = float(value)\n        elif key == 'Atomic energy':\n            res[cur_atom]['Atomic energy'] = float(value)\n    return res\n\n\ndef read_fireball_in(fpath='fireball.in'):\n\n    rf = open(fpath)\n    data = rf.readlines()\n    ret = {}\n\n    for iline in data:\n        if iline.startswith('&'):\n            if iline.startswith('&END'):\n                curkey=None\n            else:\n                curkey=iline[1:].strip()\n        elif '=' in iline:\n            varname = iline.split('=')[0].strip()\n            value = iline.split('=')[1].strip()\n            if curkey is not None and curkey not in ret:\n                ret[curkey]={}\n            ret[curkey][varname] = value\n    return ret\n\n\ndef read_eigen(fpath='eigen.dat'):\n\n    rf =open(fpath)\n    data=rf.read()\n    # Number of Eigenvalues\n    nval = int(data.split()[1])\n    # The eigenvalues\n    eigen = [float(x) for x in data.split()[7:]]\n    assert(len(eigen) == nval)\n    return eigen\n\n\ndef read_final_fireball_relax(fpath):\n\n    ", "suffix":""}
